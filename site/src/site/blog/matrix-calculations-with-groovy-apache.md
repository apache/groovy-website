---
layout: post
title: Matrix calculations with Groovy, Apache Commons Math, ojAlgo, Nd4j and EJML
date: '2022-08-18T13:41:03+00:00'
permalink: matrix-calculations-with-groovy-apache
---
<p>This blogs looks at performing matrix calculations with Groovy using various libraries:&nbsp;<a href="https://commons.apache.org/" target="_blank">Apache Commons</a> <a href="https://commons.apache.org/proper/commons-math/" target="_blank">Math</a>, <a href="https://www.ojalgo.org/" target="_blank">ojAlgo</a>, <a href="https://ejml.org/" target="_blank">EJML</a>, and <a href="https://deeplearning4j.konduit.ai/nd4j/tutorials/quickstart" target="_blank">Nd4j</a>&nbsp;(part of Eclipse <a href="https://deeplearning4j.konduit.ai/" target="_blank">Deeplearning4j</a>). We'll also take a quick look at using the incubating Vector API for matrix calculations (JEPs&nbsp;<a href="https://openjdk.org/jeps/338" target="_blank">338</a>, <a href="https://openjdk.org/jeps/414" target="_blank">414</a>,&nbsp;<a href="https://openjdk.org/jeps/417" target="_blank">417</a>,&nbsp;<a href="https://openjdk.org/jeps/426" target="_blank">426</a>).</p>
<h3>Fibonacci</h3><p>The Fibonacci sequence has origins in India centuries earlier but is named after the Italian author of the publication, <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank">The Book of Calculation</a>, published in 1202. In that publication, Fibonacci proposed the sequence as a means&nbsp;to calculate the growth of&nbsp;idealized (biologically unrealistic)&nbsp;<span style="background-image: none; background-position: initial; background-size: initial; background-repeat: initial; background-attachment: initial; background-origin: initial; background-clip: initial;">rabbit</span>&nbsp;populations.&nbsp;He proposed that a newly born breeding pair of rabbits are put in a field; each breeding pair mates at the age of one month, and at the end of their second month they always produce another pair of rabbits; and rabbits never die, but continue breeding forever. Fibonacci posed the puzzle: how many pairs will there be in one year? The sequence goes like this:</p>

<pre>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233</pre>

<p>We can solve this problem using matrices. If we multiply the matrix <img src="https://blogs.apache.org/groovy/mediaresource/473d4a77-a5ea-4ccb-9d55-4936decf74f0" style="width:5%;" alt="2022-08-18 23_42_31-ASF Blogs_ Edit Entry.png">&nbsp;by itself <i>n</i> times we get&nbsp;<img src="https://blogs.apache.org/groovy/mediaresource/3aa6c41b-4458-400a-9350-b0b2fce0ca99" style="width:10%;" alt="2022-08-18 23_42_48-ASF Blogs_ Edit Entry.png">. This is an operation known as matrix exponentiation. Let's explore this problem using four of the most popular and maintained matrix libraries.</p>
<h4>Apache Commons Math</h4><p>Let's explore solving this problem using Apache Commons Math. Apache Commons Math is a library of lightweight self-contained mathematics and statics components. Matrices are part of the linear algebra part of this library and for that context, matrices of double values are relevant. So, we'll represent our Fibonacci numbers as double values.</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">double</span>[][] data = [[<span style="color:#6897bb;">1d</span>, <span style="color:#6897bb;">1d</span>], [<span style="color:#6897bb;">1d</span>, <span style="color:#6897bb;">0d</span>]]<br><span style="color:#cc7832;">def </span>m = MatrixUtils.<span style="color:#9876aa;font-style:italic;">createRealMatrix</span>(data)<br>println m * m * m<br>println m**<span style="color:#6897bb;">6<br></span></pre><p>Commons math has a factory method for creating matrixes from double arrays. The names of the methods for multiplication and exponentiation happen to align with Groovy's methods available for operator overloading, namely <code>multiply</code> and <code>power</code>, so we can use Groovy's convenient shorthands.</p><p>When we run the script, the output looks like this:</p>
<pre>Array2DRowRealMatrix{{3.0,2.0},{2.0,1.0}}
Array2DRowRealMatrix{{13.0,8.0},{8.0,5.0}}
</pre>
<p>We could go a little further and print the values from the matrix, but the result is clear enough. We see the values in the Fibonacci sequence appearing in the output.</p>
<h4>EJML</h4><p>EJML (Efficient Java Matrix Library) is a linear algebra library for manipulating real, complex, dense, and sparse matrices. It is also a 100% Java solution. It has some novel features including import from Matlab and support for semirings (<a href="https://en.wikipedia.org/wiki/GraphBLAS" target="_blank">GraphBLAS</a>) which can be used for graph algorithms where a sparse matrix may be used to represent a graph as an adjacency matrix or incidence matrix.</p><p>We can do the same calculation using EJML:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>m = <span style="color:#cc7832;">new </span>SimpleMatrix([[<span style="color:#6897bb;">1d</span>, <span style="color:#6897bb;">1d</span>], [<span style="color:#6897bb;">1d</span>, <span style="color:#6897bb;">0d</span>]] <span style="color:#cc7832;">as double</span>[][])<br><span style="color:#cc7832;">def </span>ans = m.mult(m).mult(m)<br>println ans<br><span style="color:#6897bb;">6</span>.times <span style="font-weight:bold;">{ </span>ans = ans.mult(m) <span style="font-weight:bold;">}<br></span>println ans<br></pre><p>The name of the multiply method differs from the one where we can use automatic operator overloading shorthands, so we just call the method that EJML provides. See a little later under language extensibility on how we could in fact add support to use the same shorthands as we saw for Commons Math.</p><p>EJML doesn't have an exponentiation method but we just call multiply the requisite number of times to achieve the same effect. Note that we bumped the number of iterations called for the second matrix, to reveal the next bunch of elements from the Fibonacci sequence.</p><p>Running this script has this output:</p>
<pre>Type = DDRM , rows = 2 , cols = 2
 3.0000E+00  2.0000E+00 
 2.0000E+00  1.0000E+00 

Type = DDRM , rows = 2 , cols = 2
 5.5000E+01  3.4000E+01 
 3.4000E+01  2.1000E+01
</pre>
<p>The first matrix has the same number as previously, and the second reveals the next numbers in the Fibonacci sequence (21, 34, and 55).</p>
<h4>Nd4j</h4><p>Nd4j provides functionality available on Python to Java users. It&nbsp;contains a mix of numpy operations and tensorflow/pytorch operations. Nd4l makes use of native backends to allow it to work on different platforms and provide efficient operation when scaling up.</p><p>The code for our Fibonacci solution is very similar to EJML:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>m = Nd4j.<span style="color:#9876aa;font-style:italic;">create</span>([[<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">1</span>], [<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">0</span>]] <span style="color:#cc7832;">as int</span>[][])<br><span style="color:#cc7832;">def </span>ans = m.mmul(m).mmul(m)<br>println ans<br><span style="color:#6897bb;">9</span>.times <span style="font-weight:bold;">{ </span>ans = ans.mmul(m) <span style="font-weight:bold;">}<br></span>println ans<br></pre>
<p>One feature that is different to the previous two libraries is that Nd4j supports <i>integer </i>matrices (as well as doubles and numerous other numerical and related types).</p><p>Running the script gives the following output:</p>
<pre><span style="color:#d03030">...
[main] INFO org.nd4j.linalg.factory.Nd4jBackend - Loaded [CpuBackend] backend
...
[main] INFO org.nd4j.linalg.cpu.nativecpu.CpuNDArrayFactory - Binary level Generic x86 optimization level AVX/AVX2
[main] INFO org.nd4j.linalg.api.ops.executioner.DefaultOpExecutioner - Blas vendor: [OPENBLAS]
...</span>
[[         3,         2], 
 [         2,         1]]
[[       233,       144], 
 [       144,        89]]
</pre>
<p>Again, the first matrix is the same as we have seen previously, the second has been bumped along the Fibonacci sequence by three more elements.</p>
<h4>ojAlgo</h4><p>The next library we'll look at is ojAlgo (oj! Algorithms). It is an open source all-Java offering for mathematics, linear algebra and optimisation, supporting data science, machine learning and scientific computing. It claims to be the fastest pure-Java linear algebra library available and the project website provide links to numerous benchmarks backing that claim.<br></p><p>Here is the code for our Fibonacci example:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>factory = Primitive64Matrix.<span style="color:#9876aa;font-style:italic;">FACTORY<br></span><span style="color:#cc7832;">def </span>m = factory.rows([[<span style="color:#6897bb;">1d</span>, <span style="color:#6897bb;">1d</span>], [<span style="color:#6897bb;">1d</span>, <span style="color:#6897bb;">0d</span>]] <span style="color:#cc7832;">as double</span>[][])<br>println m * m * m<br>println m**<span style="color:#6897bb;">15<br></span></pre><p>We can see it supports the same operator overloading features we saw for Commons Math.</p><p>When we run the script, it has the following output:</p>
<pre>org.ojalgo.matrix.Primitive64Matrix &lt; 2 x 2 &gt;
{ { 3.0,	2.0 },
{ 2.0,	1.0 } }
org.ojalgo.matrix.Primitive64Matrix &lt; 2 x 2 &gt;
{ { 987.0,	610.0 },
{ 610.0,	377.0 } }
</pre>
<p>As expected, the first matrix is as we've seen before, while the second reveals the next three numbers in the sequence.</p><h4>Exploring the Vector API and EJML</h4>

<p>From JDK16, various versions (JEPs&nbsp;<a href="https://openjdk.org/jeps/338" target="_blank" style="background-color: rgb(255, 255, 255);">338</a>,&nbsp;<a href="https://openjdk.org/jeps/414" target="_blank" style="background-color: rgb(255, 255, 255);">414</a>,&nbsp;<a href="https://openjdk.org/jeps/417" target="_blank" style="background-color: rgb(255, 255, 255);">417</a>,&nbsp;<a href="https://openjdk.org/jeps/426" target="_blank" style="background-color: rgb(255, 255, 255);">426</a>) of the Vector API have been available as an incubating preview feature. The HotSpot compiler has previously already had some minimal optimisations that can leverage vector hardware instructions but the Vector API expands the scope of possible optimisations considerably. We could look at writing our own code that might make use of the Vector API and perhaps perform our matrix multiplications ourselves. But, one of the libraries has already done just that, so we'll explore that path.</p><p>The main contributor to the EJML library has published a <a href="https://github.com/lessthanoptimal/VectorPerformance" target="_blank">repo</a> for the purposes of very early prototyping and benchmarking. We'll use the methods from one of its classes to explore use of the vector API for our Fibonacci example. The <code>MatrixMultiplication</code> class has three methods: <code>mult_ikj_simple</code> is coded in the way any of us might write a multiplication method as a first pass from its definition without any attempts at optimisation, <code>mult_ikj</code> is coded in a highly-optimised fashion and corresponds to the code EJML would normally use, and <code>mult_ikj_vector</code> uses the Vector API. Note, you can think of these methods as "one layer down" from the <code>mult</code> method we called in the previous example, i.e. the <code>mult</code> method we used previously would be calling one of these under the covers. That's why we pass the internal "matrix" representation instead of our <code>SimpleMatrix</code> instance.</p><p>For our little calculations, the optimisations offered by the Vector API would not be expected to be huge. However, we'll do our calculation for generating the matrix we did as a first step for all of the libraries and we'll do it in a loop with 1000 iterations for each of the three methods (<code>mult_ikj_simple</code>, <code>mult_ikj</code>, and <code>mult_ikj_vector</code>). The code looks like this:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>m = <span style="color:#cc7832;">new </span>SimpleMatrix([[<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">1</span>], [<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">0</span>]] <span style="color:#cc7832;">as double</span>[][])<br><span style="color:#cc7832;">double</span>[] expected = [<span style="color:#6897bb;">3</span>, <span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">1</span>]<br><span style="color:#cc7832;">def </span>step1, result
<br><span style="color:#cc7832;">long </span>t0 = System.<span style="color:#9876aa;font-style:italic;">nanoTime</span>()<br><span style="color:#6897bb;">1000</span>.times <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>step1 = <span style="color:#cc7832;">new </span>SimpleMatrix(<span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">2</span>)<br>    result = <span style="color:#cc7832;">new </span>SimpleMatrix(<span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">2</span>)<br>    MatrixMultiplication.<span style="color:#9876aa;font-style:italic;">mult_ikj_simple</span>(m.<span style="color:#9876aa;">matrix</span>, m.<span style="color:#9876aa;">matrix</span>, step1.<span style="color:#9876aa;">matrix</span>)<br>    MatrixMultiplication.<span style="color:#9876aa;font-style:italic;">mult_ikj_simple</span>(step1.<span style="color:#9876aa;">matrix</span>, m.<span style="color:#9876aa;">matrix</span>, result.<span style="color:#9876aa;">matrix</span>)<br>    <span style="color:#cc7832;">assert </span>result.<span style="color:#9876aa;">matrix</span>.data == expected<br><span style="font-weight:bold;">}
<br></span><span style="color:#cc7832;">long </span>t1 = System.<span style="color:#9876aa;font-style:italic;">nanoTime</span>()<br><span style="color:#6897bb;">1000</span>.times <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>step1 = <span style="color:#cc7832;">new </span>SimpleMatrix(<span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">2</span>)<br>    result = <span style="color:#cc7832;">new </span>SimpleMatrix(<span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">2</span>)<br>    MatrixMultiplication.mult_ikj(m.<span style="color:#9876aa;">matrix</span>, m.<span style="color:#9876aa;">matrix</span>, step1.<span style="color:#9876aa;">matrix</span>)<br>    MatrixMultiplication.mult_ikj(step1.<span style="color:#9876aa;">matrix</span>, m.<span style="color:#9876aa;">matrix</span>, result.<span style="color:#9876aa;">matrix</span>)<br>    <span style="color:#cc7832;">assert </span>result.<span style="color:#9876aa;">matrix</span>.data == expected<br><span style="font-weight:bold;">}
<br></span><span style="color:#cc7832;">long </span>t2 = System.<span style="color:#9876aa;font-style:italic;">nanoTime</span>()<br><span style="color:#6897bb;">1000</span>.times <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span>step1 = <span style="color:#cc7832;">new </span>SimpleMatrix(<span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">2</span>)<br>    result = <span style="color:#cc7832;">new </span>SimpleMatrix(<span style="color:#6897bb;">2</span>, <span style="color:#6897bb;">2</span>)<br>    MatrixMultiplication.mult_ikj_vector(m.<span style="color:#9876aa;">matrix</span>, m.<span style="color:#9876aa;">matrix</span>, step1.<span style="color:#9876aa;">matrix</span>)<br>    MatrixMultiplication.mult_ikj_vector(step1.<span style="color:#9876aa;">matrix</span>, m.<span style="color:#9876aa;">matrix</span>, result.<span style="color:#9876aa;">matrix</span>)<br>    <span style="color:#cc7832;">assert </span>result.<span style="color:#9876aa;">matrix</span>.data == expected<br><span style="font-weight:bold;">}
<br></span><span style="color:#cc7832;">long </span>t3 = System.<span style="color:#9876aa;font-style:italic;">nanoTime</span>()<br>printf <span style="color:#6a8759;">"Simple:    %6.2f ms</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"</span>, (t1 - t0)/<span style="color:#6897bb;">1000_000<br></span>printf <span style="color:#6a8759;">"Optimized: %6.2f ms</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"</span>, (t2 - t1)/<span style="color:#6897bb;">1000_000<br></span>printf <span style="color:#6a8759;">"Vector:    %6.2f ms</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">"</span>, (t3 - t2)/<span style="color:#6897bb;">1000_000</span></pre><p>This example was run on JDK16 with the following VM options: "<code>--enable-preview --add-modules jdk.incubator.vector</code>".</p><p>The output looks like this:</p>
<pre><span style="color:#d03030">WARNING: Using incubator modules: jdk.incubator.vector</span>
Simple:    116.34 ms
Optimized:  34.91 ms
Vector:     21.94 ms
</pre>
<p>We can see here that we have some improvement even for our trivial little calculation. Certainly, for biggest problems, the benefit of using the Vector API could be quite substantial.</p><p>We should give a big disclaimer here. This little microbenchmark using a loop of 1000 will give highly variable results and was just done to give a very simple performance comparison. For a more predictable comparison, consider running the <a href="https://github.com/openjdk/jmh" target="_blank">jmh</a> benchmark in the aforementioned&nbsp;<a href="https://github.com/lessthanoptimal/VectorPerformance" target="_blank" style="background-color: rgb(255, 255, 255);">repo</a>. And you may wish to wait until the Vector API is out of preview before relying on it for any production code - but by all means, consider trying it out now.</p>

<h3>Leslie Matrices</h3>

<p>Earlier, we described the Fibonacci sequence as being for <i>unrealistic</i> rabbit populations, where rabbits never died and continued breeding forever. It turns out that Fibonacci matrices are a special case of a more generalised model which can model realistic rabbit populations (among other things). These are <a href="https://en.wikipedia.org/wiki/Leslie_matrix" target="_blank">Leslie matrices</a>. For Leslie matrices, populations are divided into classes, and we keep track of birth rates and survival rates over a particular period for each class. We store this information in a matrix in a special form. The populations for each class for the next period can be calculated from those for the current period through multiplication by the Leslie matrix.</p><p>This technique can be used for animal populations or human population calculations. A Leslie matrix can help you find out if there will be enough GenX, Millenials, and GenZ tax payers to support an aging and soon retiring baby boomer population. Sophisticated animal models might track populations for an animal and for its predators or its prey. The survival and birth rates might be adjusted based on such information. Given that only females give birth, Leslie models will often be done only in terms of the female population, with the total population extrapolated from that.</p><p>We'll show an example for kangaroo population based on this <a href="https://www.youtube.com/watch?v=I5WM2wdjr1M" target="_blank">video tutorial</a>&nbsp;for Leslie matrices. It can help us find out if the kangaroo population is under threat (perhaps drought, fires or floods have impacted their feeding habitat) or if favorable conditions are leading to overpopulation.</p><p>Following that example, we divide kangaroos into 3 population classes: ages 0 to 3, 3 to 6, and 6 to 9. We are going to look at the population every three years. The 0-3 year olds birthrate (B1) is 0 since they are pre-fertile. The most fertile 3-6 year olds birthrate (B2) is 2.3. The old roos (6-9) have a birthrate (B3) of 0.4. We assume no kangaroos survive past 9 years old. 60% (S1) of the young kangaroos survive to move into the next age group. 30% (S2) of the middle-aged kangaroos survive into old age. Initially, we have 400 kangaroos in each age group.</p><p>Here is what the code looks like for this model:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">double</span>[] init = [<span style="color:#6897bb;">400</span>,   <span style="color:#808080;">// 0..&lt;3<br></span><span style="color:#808080;">                 </span><span style="color:#6897bb;">400</span>,   <span style="color:#808080;">// 3..&lt;6<br></span><span style="color:#808080;">                 </span><span style="color:#6897bb;">400</span>]   <span style="color:#808080;">// 6..9<br></span><span style="color:#cc7832;">def </span>p0 = MatrixUtils.<span style="color:#9876aa;font-style:italic;">createRealVector</span>(init)<br>println <span style="color:#6a8759;">"Initial populations: </span>$p0<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;"><br></span><span style="color:#cc7832;">double</span>[][] data = [<br>        [<span style="color:#6897bb;">0  </span>, <span style="color:#6897bb;">2.3</span>, <span style="color:#6897bb;">0.4</span>],   <span style="color:#808080;">// B1 B2 B3<br></span><span style="color:#808080;">        </span>[<span style="color:#6897bb;">0.6</span>,   <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">0  </span>],   <span style="color:#808080;">// S1  0  0<br></span><span style="color:#808080;">        </span>[<span style="color:#6897bb;">0  </span>, <span style="color:#6897bb;">0.3</span>, <span style="color:#6897bb;">0  </span>]    <span style="color:#808080;">//  0 S2  0<br></span>]<br><span style="color:#cc7832;">def </span>L = MatrixUtils.<span style="color:#9876aa;font-style:italic;">createRealMatrix</span>(data)<br><span style="color:#cc7832;">def </span>p1 = L.operate(p0)<br>println <span style="color:#6a8759;">"Population after 1 round: </span>$p1<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;"><br></span><span style="color:#cc7832;">def </span>p2 = L.operate(p1)<br>println <span style="color:#6a8759;">"Population after 2 rounds: </span>$p2<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;"><br></span><span style="color:#cc7832;">def </span>L10 = L ** <span style="color:#6897bb;">10<br></span>println <span style="color:#6a8759;">"Population after 10 rounds: </span>$<span style="font-weight:bold;">{</span>L10.operate(p0).toArray()*.round()<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"</span></pre><p>This code produces the following output:</p>
<pre>Initial populations: {400; 400; 400}
Population after 1 round: {1,080; 240; 120}
Population after 2 rounds: {600; 648; 72}
Population after 10 rounds: [3019, 2558, 365]</pre>
<p>After the first round, we see many young roos but a worrying drop off in the older age groups. After the second round, only the oldest age group looks worryingly small. However, with the healthy numbers in the young generation, we can see that after 10 generations that indeed, the overall population is not at risk. In fact, overpopulation might become a problem.</p>

<h3>Encryption with matrices</h3>

<p>An early technique to encrypt a message was the <a href="https://en.wikipedia.org/wiki/Caesar_cipher" target="_blank">Caesar cipher</a>. It substitutes letters in the alphabet by the letter shifted a certain amount along in the alphabet, e.g. "IBM" becomes "HAL" if shifting to the previous letter and "VMS" becomes "WNT" if shifting one letter forward in the alphabet. This kind of cipher can be broken by looking at frequency analysis of letters or pattern words.</p><p>The <a href="https://en.wikipedia.org/wiki/Hill_cipher" target="_blank">Hill cipher</a> improves upon the Caesar cipher by factoring multiple letters into each letter of the encrypted text. Using matrices made it practical to look at three or more symbols at once. In general, an N-by-N matrix (the key) is multiplied by an encoding of the message in matrix form. The result is a matrix representation (encoded form) of the encrypted text. We use the inverse matrix of our key to decrypt or message.</p><p>We need to have a way to convert our text message to and from a matrix. A common scheme is to encode A as 1, B as 2, and so on. We'll just use the ascii value for each character. We define encode and decode methods to do this:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">double</span>[][] encode(String s) { s.<span style="color:#9876aa;">bytes</span>*.intValue().collate(<span style="color:#6897bb;">3</span>) <span style="color:#cc7832;">as double</span>[][] }<br>String decode(<span style="color:#cc7832;">double</span>[] data) { data*.round() <span style="color:#cc7832;">as char</span>[] }<br></pre><p>We'll define a 2-by-2 matrix as our key and use it to encrypt. We'll find the inverse of our key and use that to decrypt. If we wanted to, we could use a 3-by-3 key for improved security at the cost of more processing time.</p><p>Our code looks like this:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>message = <span style="color:#6a8759;">'GROOVY'<br></span><span style="color:#cc7832;">def </span>m = <span style="color:#cc7832;">new </span>SimpleMatrix(encode(message))<br>println <span style="color:#6a8759;">"Original: </span>$message<span style="color:#6a8759;">"<br></span><span style="color:#6a8759;"><br></span><span style="color:#cc7832;">def </span>enKey = <span style="color:#cc7832;">new </span>SimpleMatrix([[<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">3</span>], [-<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">2</span>]] <span style="color:#cc7832;">as double</span>[][])<br><span style="color:#cc7832;">def </span>encrypted = enKey.mult(m)<br>println <span style="color:#6a8759;">"Encrypted: </span>$<span style="font-weight:bold;">{</span>decode(encrypted.<span style="color:#9876aa;">matrix</span>.data)<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"<br></span><span style="color:#6a8759;"><br></span><span style="color:#cc7832;">def </span>deKey = enKey.invert()<br><span style="color:#cc7832;">def </span>decrypted = deKey.mult(encrypted)<br>println <span style="color:#6a8759;">"Decrypted: </span>$<span style="font-weight:bold;">{</span>decode(decrypted.<span style="color:#9876aa;">matrix</span>.data)<span style="font-weight:bold;">}</span><span style="color:#6a8759;">"</span></pre>
<p>When run, it has the following output:</p>
<pre>Original: GROOVY
Encrypted: ĴŔŚWZc
Decrypted: GROOVY
</pre>
<p>This offers far more security than the Caesar cipher, however, given today's computing availability, Hill ciphers can still eventually be broken with sufficient brute force. For this reason, Hill ciphers are seldom used on their own for encryption but they <i>are</i> often used in combination with other techniques to add diffusion - strengthening the security offered by the other techniques.</p>

<h3>Shape manipulation</h3>

<p>Our final example looks at geometrically transforming shapes. To do this, we represent the points of the shape as vectors and multiply them using transforms represented as matrices. We need only worry about the corners, since we'll use Swing to draw our shape and it has a method for drawing a polygon by giving its corners.</p>
<p>First we'll use Groovy's SwingBuilder to set up our frame:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">new </span>SwingBuilder().edt <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>frame = frame(<span style="color:#6a8759;">title</span>: <span style="color:#6a8759;">'Shapes'</span>, <span style="color:#6a8759;">size</span>: [<span style="color:#6897bb;">420</span>, <span style="color:#6897bb;">440</span>], <span style="color:#6a8759;">show</span>: <span style="color:#cc7832;">true</span>, <span style="color:#6a8759;">defaultCloseOperation</span>: <span style="color:#9876aa;font-style:italic;">DISPOSE_ON_CLOSE</span>) <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">        </span><span style="color:#808080;">//contentPane.background = Color.WHITE<br></span><span style="color:#808080;">        </span>widget(<span style="color:#cc7832;">new </span>CustomPaintComponent())<br>    <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>frame.<span style="color:#9876aa;">contentPane</span>.<span style="color:#9876aa;">background </span>= Color.<span style="color:#9876aa;font-style:italic;">WHITE<br></span><span style="font-weight:bold;">}<br></span></pre>
<p>We aren't really use much of SwingBuilder's functionality here but if we wanted to add more functionality, SwingBuilder would make that task easier.</p>
<p>We will actually draw our shapes within a custom component. We'll define a few color constants, a <code>drawPolygon</code> method which given a matrix of points will draw those points as a polygon. We'll also define a <code>vectors</code> method to convert a list of points (the corners) into vectors, and a <code>transform</code> method which is a factory method for creating a transform matrix.</p><p>Here is the code:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">class </span>CustomPaintComponent <span style="color:#cc7832;">extends </span>Component {<br>    <span style="color:#cc7832;">static final </span>Color <span style="color:#9876aa;font-style:italic;">violet </span>= <span style="color:#cc7832;">new </span>Color(<span style="color:#6897bb;">0x67</span>, <span style="color:#6897bb;">0x27</span>, <span style="color:#6897bb;">0x7A</span>, <span style="color:#6897bb;">127</span>)<br>    <span style="color:#cc7832;">static final </span>Color <span style="color:#9876aa;font-style:italic;">seaGreen </span>= <span style="color:#cc7832;">new </span>Color(<span style="color:#6897bb;">0x69</span>, <span style="color:#6897bb;">0xCC</span>, <span style="color:#6897bb;">0x67</span>, <span style="color:#6897bb;">127</span>)<br>    <span style="color:#cc7832;">static final </span>Color <span style="color:#9876aa;font-style:italic;">crystalBlue </span>= <span style="color:#cc7832;">new </span>Color(<span style="color:#6897bb;">0x06</span>, <span style="color:#6897bb;">0x4B</span>, <span style="color:#6897bb;">0x93</span>, <span style="color:#6897bb;">127</span>)<br>    <span style="color:#cc7832;">static </span>drawPolygon(Graphics g, List pts, <span style="color:#cc7832;">boolean </span>fill) {<br>        <span style="color:#cc7832;">def </span>poly = <span style="color:#cc7832;">new </span>Polygon().tap <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">            </span>pts.each <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">                </span>addPoint(*it.toRawCopy1D()*.round()*.intValue().collect <span style="font-weight:bold;">{ </span>it + <span style="color:#6897bb;">200 </span><span style="font-weight:bold;">}</span>)<br>            <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">        }<br></span><span style="font-weight:bold;">        </span>fill ? g.fillPolygon(poly) : g.drawPolygon(poly)<br>    }<br><br>    <span style="color:#cc7832;">static </span>List&lt;Primitive64Matrix&gt; vectors(List&lt;Integer&gt;... pts) {<br>        pts.collect<span style="font-weight:bold;">{ </span><span style="color:#9876aa;font-style:italic;">factory</span>.column(*it) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span>}<br><br>    <span style="color:#cc7832;">static </span>transform(List&lt;Number&gt;... lists) {<br>        <span style="color:#9876aa;font-style:italic;">factory</span>.rows(lists <span style="color:#cc7832;">as double</span>[][])<br>    }<br><br>    <span style="color:#cc7832;">void </span>paint(Graphics g) {<br>        g.drawLine(<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">200</span>, <span style="color:#6897bb;">400</span>, <span style="color:#6897bb;">200</span>)<br>        g.drawLine(<span style="color:#6897bb;">200</span>, <span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">200</span>, <span style="color:#6897bb;">400</span>)<br>        g.stroke = <span style="color:#cc7832;">new </span>BasicStroke(<span style="color:#6897bb;">2</span>)<br><br>        <span style="color:#cc7832;">def </span>triangle = <span style="color:#9876aa;font-style:italic;">vectors</span>([-<span style="color:#6897bb;">85</span>, -<span style="color:#6897bb;">150</span>], [-<span style="color:#6897bb;">145</span>, -<span style="color:#6897bb;">30</span>], [-<span style="color:#6897bb;">25</span>, -<span style="color:#6897bb;">30</span>])<br>        g.<span style="color:#9876aa;">color </span>= <span style="color:#9876aa;font-style:italic;">seaGreen<br></span><span style="color:#9876aa;font-style:italic;">        drawPolygon</span>(g, triangle, <span style="color:#cc7832;">true</span>)<br>        <span style="color:#808080;">// transform triangle
        ...<br></span><br>        <span style="color:#cc7832;">def </span>rectangle = <span style="color:#9876aa;font-style:italic;">vectors</span>([<span style="color:#6897bb;">0</span>, -<span style="color:#6897bb;">110</span>], [<span style="color:#6897bb;">0</span>, -<span style="color:#6897bb;">45</span>], [<span style="color:#6897bb;">95</span>, -<span style="color:#6897bb;">45</span>], [<span style="color:#6897bb;">95</span>, -<span style="color:#6897bb;">110</span>])<br>        g.<span style="color:#9876aa;">color </span>= <span style="color:#9876aa;font-style:italic;">crystalBlue<br></span><span style="color:#9876aa;font-style:italic;">        drawPolygon</span>(g, rectangle, <span style="color:#cc7832;">true</span>)<br>        <span style="color:#808080;">// transform rectangle
        ...<br></span><br>        <span style="color:#cc7832;">def </span>trapezoid = <span style="color:#9876aa;font-style:italic;">vectors</span>([<span style="color:#6897bb;">50</span>, <span style="color:#6897bb;">50</span>], [<span style="color:#6897bb;">70</span>, <span style="color:#6897bb;">100</span>], [<span style="color:#6897bb;">100</span>, <span style="color:#6897bb;">100</span>], [<span style="color:#6897bb;">120</span>, <span style="color:#6897bb;">50</span>])<br>        g.<span style="color:#9876aa;">color </span>= <span style="color:#9876aa;font-style:italic;">violet<br></span><span style="color:#9876aa;font-style:italic;">        drawPolygon</span>(g, trapezoid, <span style="color:#cc7832;">true</span>)<br>        <span style="color:#808080;">// transform trapezoid
        ...<br></span><span style="font-weight:bold;">    </span>}<br>}</pre><p>When we run this code we see our three shapes:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/2050e66e-86ef-4307-a1bf-dde13b786bdc" style="width:50%;;border: 1px solid #555;" alt="2022-08-18 00_02_11-Shapes.png"><br></p><p>We can now add our transforms. We'll have one which rotate by 90 degrees anti-clockwise. Another which enlarges a shape by 25% and one that shrinks a shape by 25%. We can combine transforms simply by multiplying them together. We'll make two transformations of our triangle. We'll rotate in both cases but we'll shrink one and enlarge the other. We apply the transform simply by multiplying each point by the transform matrix. Then we'll draw both transformed shapes as an outline rather than filled (to make it easier to distinguish the original and transformed versions). Here is the code:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>rot90 = <span style="color:#9876aa;font-style:italic;">transform</span>([<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">1</span>], [-<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">0</span>])<br><span style="color:#cc7832;">def </span>bigger = <span style="color:#9876aa;font-style:italic;">transform</span>([<span style="color:#6897bb;">1.25</span>, <span style="color:#6897bb;">0</span>], [<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">1.25</span>])<br><span style="color:#cc7832;">def </span>smaller = <span style="color:#9876aa;font-style:italic;">transform</span>([<span style="color:#6897bb;">0.75</span>, <span style="color:#6897bb;">0</span>], [<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">0.75</span>])<br><span style="color:#cc7832;">def </span>triangle_ = triangle.collect<span style="font-weight:bold;">{ </span>rot90 * bigger * it <span style="font-weight:bold;">}<br></span><span style="color:#9876aa;font-style:italic;">drawPolygon</span>(g, triangle_, <span style="color:#cc7832;">false</span>)<br>triangle_ = triangle.collect<span style="font-weight:bold;">{ </span>rot90 * smaller * it <span style="font-weight:bold;">}<br></span><span style="color:#9876aa;font-style:italic;">drawPolygon</span>(g, triangle_, <span style="color:#cc7832;">false</span>)<br></pre><p>For our rectangle, we'll have one simple transform which flips the shape in the vertical axis. A second transform combines multiple changes in one transform. We could have split this into smaller transforms and the multiplied them together - but here they are all in one. We flip in the horizontal access and then apply a shear. We then draw the transformed shapes as outlines:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>flipV = <span style="color:#9876aa;font-style:italic;">transform</span>([<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">0</span>], [<span style="color:#6897bb;">0</span>, -<span style="color:#6897bb;">1</span>])<br><span style="color:#cc7832;">def </span>rectangle_ = rectangle.collect<span style="font-weight:bold;">{ </span>flipV * it <span style="font-weight:bold;">}<br></span><span style="color:#9876aa;font-style:italic;">drawPolygon</span>(g, rectangle_, <span style="color:#cc7832;">false</span>)<br><span style="color:#cc7832;">def </span>flipH_shear = <span style="color:#9876aa;font-style:italic;">transform</span>([-<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">0.5</span>], [<span style="color:#6897bb;">0</span>, <span style="color:#6897bb;">1</span>])<br>rectangle_ = rectangle.collect<span style="font-weight:bold;">{ </span>flipH_shear * it <span style="font-weight:bold;">}<br></span><span style="color:#9876aa;font-style:italic;">drawPolygon</span>(g, rectangle_, <span style="color:#cc7832;">false</span>)<br></pre><p>For our trapezoid, we create a transform which rotates 45 degrees anti-clockwise (recall sin 45° = cos 45° = 0.707). Then we create 6 transforms rotating at 45, 90, 135 and so forth. We draw each transformed shape as an outline:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>rot45 = <span style="color:#9876aa;font-style:italic;">transform</span>([<span style="color:#6897bb;">0.707</span>, <span style="color:#6897bb;">0.707</span>], [-<span style="color:#6897bb;">0.707</span>, <span style="color:#6897bb;">0.707</span>])<br><span style="color:#cc7832;">def </span>trapezoid_<br>(<span style="color:#6897bb;">1</span>..<span style="color:#6897bb;">6</span>).each <span style="font-weight:bold;">{ </span>z <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span>trapezoid_ = trapezoid.collect<span style="font-weight:bold;">{ </span>rot45 ** z * it <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">    </span><span style="color:#9876aa;font-style:italic;">drawPolygon</span>(g, trapezoid_, <span style="color:#cc7832;">false</span>)<br><span style="font-weight:bold;">}<br></span></pre><p>When we run the entire example, here is what the output looks like:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/7770e9bb-3c93-4288-ae5d-b2a449cfcd47" style="width:50%;border: 1px solid #555;" alt="2022-08-18 00_00_48-Shapes.png"><br></p><p>We can see here that matrix transforms give us powerful ways to manipulate images. We have used 2D images here, but the same techniques would apply to 3D shapes.</p>

<h3>Language and tool extensibility</h3>

<p>We saw earlier that some of the examples could make use of Groovy operator shorthand syntax, while others couldn't. Here is a summary of some common methods in the libraries:</p>
<p></p><table style="border:1px solid gray; margin:5px;"><tbody>
<tr style="background-color:#ADD8E6"><td style="text-align:center;padding:5px;">Groovy operator</td><td style="text-align:center;padding:5px;">+</td><td style="text-align:center;padding:5px;">-</td><td style="text-align:center;padding:5px;">*</td><td style="text-align:center;padding:5px;">**</td></tr>
<tr style="background-color:#ADD8E6"><td style="text-align:center;padding:5px;">Groovy method</td><td style="text-align:center;padding:5px;">plus</td><td style="text-align:center;padding:5px;">minus</td><td style="text-align:center;padding:5px;">multiply</td><td style="text-align:center;padding:5px;">power</td></tr>
<tr><td style="text-align:center;padding:5px;">Commons math</td><td style="text-align:center;padding:5px;">add</td><td style="text-align:center;padding:5px;">subtract</td><td style="text-align:center;padding:5px;">multiply</td><td style="text-align:center;padding:5px;">power</td></tr>
<tr><td style="text-align:center;padding:5px;">EJML</td><td style="text-align:center;padding:5px;">plus</td><td style="text-align:center;padding:5px;">minus</td><td style="text-align:center;padding:5px;">mult</td><td style="text-align:center;padding:5px;">-</td></tr>
<tr><td style="text-align:center;padding:5px;">Nd4j</td><td style="text-align:center;padding:5px;">add</td><td style="text-align:center;padding:5px;">sub</td><td style="text-align:center;padding:5px;">mmul</td><td style="text-align:center;padding:5px;">-</td></tr>
<tr><td style="text-align:center;padding:5px;">ojAlgo</td><td style="text-align:center;padding:5px;">add</td><td style="text-align:center;padding:5px;">subtract</td><td style="text-align:center;padding:5px;">multiply</td><td style="text-align:center;padding:5px;">power</td>
</tr></tbody></table><p>
</p><p>Where the library used the same name as Groovy's method, the shorthand could be used.</p><p>Groovy offers numerous extensibility features. We won't go into all of the details but instead refer readers to the <a href="https://dl.acm.org/doi/abs/10.1145/3386326" target="_blank">History of Groovy</a> paper which gives more details.</p><p>In summary, that paper defined the following extensions for Commons Math matrices:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">RealMatrix.metaClass <span style="font-weight:bold;">{<br></span><span style="font-weight:bold;">  </span>plus &lt;&lt; <span style="font-weight:bold;">{ </span>RealMatrix ma <span style="font-weight:bold;">-&gt; </span><span style="color:#9876aa;">delegate</span>.add(ma) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">  </span>plus &lt;&lt; <span style="font-weight:bold;">{ </span><span style="color:#cc7832;">double </span>d <span style="font-weight:bold;">-&gt; </span><span style="color:#9876aa;">delegate</span>.scalarAdd(d) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">  </span>multiply <span style="font-weight:bold;">{ </span><span style="color:#cc7832;">double </span>d <span style="font-weight:bold;">-&gt; </span><span style="color:#9876aa;">delegate</span>.scalarMultiply(d) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">  </span>bitwiseNegate <span style="font-weight:bold;">{ -&gt; </span><span style="color:#cc7832;">new </span>LUDecomposition(<span style="color:#9876aa;">delegate</span>).<span style="color:#9876aa;">solver</span>.<span style="color:#9876aa;">inverse </span><span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">  </span>constructor = <span style="font-weight:bold;">{ </span>List l <span style="font-weight:bold;">-&gt; </span>MatrixUtils.<span style="color:#9876aa;font-style:italic;">createRealMatrix</span>(l <span style="color:#cc7832;">as double</span>[][]) <span style="font-weight:bold;">}<br></span><span style="font-weight:bold;">}<br></span></pre><p>This fixes some of the method name discrepancies in the above table. We can now use the operator shorthand for matrix and scalar addition as well as scalar multiply. We can also use the ~ (<code>bitwiseNegate</code>) operator when finding the inverse. The mention of <code>double[][]</code>&nbsp;during matrix construction is now also gone.</p><p>The paper goes on to discuss how to automatically add the necessary imports for a matrix library and provide aliases if needed. The imports aren't shown for the code listings in this blog but are in the listings in the sample code repo. In any case, the imports can be "configured away" as the paper discusses. The end result is our code in its entirety can look like this:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">var </span>m = <span style="color:#e8bf6a;font-weight:bold;">[</span>[<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">1</span>], [<span style="color:#6897bb;">1</span>, <span style="color:#6897bb;">0</span>]<span style="color:#e8bf6a;font-weight:bold;">] </span><span style="color:#cc7832;">as </span>Matrix<br>m**<span style="color:#6897bb;">6<br></span></pre><p>The paper also discusses tooling extensibility, in particular the visualisation aspects of the GroovyConsole. It shows how to define an output transform which renders any matrix result using a jlatexmath library. So instead of seeing "<span style="background-color: rgb(245, 245, 245); color: rgb(51, 51, 51); font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 13px;">Array2DRowRealMatrix{{13.0,8.0},{8.0,5.0}}</span>", they will see a graphical rendition of the matrix. So, the final end-user experience when using the GroovyConsole looks like this:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/fbe0190b-f598-41e7-8673-6208c978dd5d" alt="2022-08-18 00_28_04-bin.png"><br></p><p>When using in Jupyter style environments, other pretty output styles may be supported.</p>

<h3>Further information</h3>

<ul>
<li>Apache Commons Math <a href="https://commons.apache.org/proper/commons-math/userguide/linear.html" target="_blank">User Guide</a>&nbsp;and <a href="https://github.com/apache/commons-math" target="_blank">github mirror</a><br></li>
<li>ojAlgo <a href="https://www.ojalgo.org/" target="_blank">website</a>&nbsp;and <a href="https://github.com/optimatika/ojAlgo/" target="_blank">github repo</a></li>
<li>EJML <a href="http://ejml.org/" target="_blank">website</a> and <a href="https://github.com/lessthanoptimal/ejml" target="_blank">github repo</a></li><li>Nd4j <a href="https://deeplearning4j.konduit.ai/nd4j/tutorials/quickstart" target="_blank">documentation</a>&nbsp;and <a href="https://github.com/eclipse/deeplearning4j/tree/master/nd4j" target="_blank">github repo</a></li>
<li><a href="https://github.com/paulk-asert/MatrixGroovy" target="_blank">Example code repo</a></li><li><a href="https://www.youtube.com/watch?v=I5WM2wdjr1M" target="_blank">Leslie Matrices for population age distribution modelling</a>&nbsp;video</li>
<li><a href="https://dl.acm.org/doi/abs/10.1145/3386326" target="_blank">A history of the Groovy programming language</a>&nbsp;paper</li>
<li><a href="https://medium.com/@Styp/java-18-vector-api-do-we-get-free-speed-up-c4510eda50d2" target="_blank">Java 18: Vector API — Do we get free speed-up?</a> blog post<br></li></ul>

<h3>Conclusion</h3>

<p>We have examined a number of simple applications of matrices using the Groovy programming language and the Apache Commons Math, ojAlgo, Nd4j, and JEML libraries. You should be convinced that using matrices on the JVM isn't hard and you have numerous options. We also saw a brief glimpse at the Vector API which looks like an exciting addition to the JVM (hopefully arriving soon in non-preview mode).</p><p><br></p>
