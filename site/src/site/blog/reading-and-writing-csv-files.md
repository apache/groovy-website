---
layout: post
title: Reading and Writing CSV files with Groovy
date: '2022-07-25T14:26:20+00:00'
permalink: reading-and-writing-csv-files
---
<p>In this post, we'll look at reading and writing CSV files using Groovy.</p>
<h3>Aren't CSV files just text files?</h3>
<p>For simple cases, we can treat CSV files no differently than we would other text files. Suppose we have the following data that we would like to write to a CSV file:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>data = [<br>        [<span style="color:#6a8759;">'place'</span>, <span style="color:#6a8759;">'firstname'</span>, <span style="color:#6a8759;">'lastname'</span>, <span style="color:#6a8759;">'team'</span>],<br>        [<span style="color:#6a8759;">'1'</span>, <span style="color:#6a8759;">'Lorena'</span>, <span style="color:#6a8759;">'Wiebes'</span>, <span style="color:#6a8759;">'Team DSM'</span>],<br>        [<span style="color:#6a8759;">'2'</span>, <span style="color:#6a8759;">'Marianne'</span>, <span style="color:#6a8759;">'Vos'</span>, <span style="color:#6a8759;">'Team Jumbo Visma'</span>],<br>        [<span style="color:#6a8759;">'3'</span>, <span style="color:#6a8759;">'Lotte'</span>, <span style="color:#6a8759;">'Kopecky'</span>, <span style="color:#6a8759;">'Team SD Worx'</span>]<br>]<br></pre>
<p>Groovy uses <code>File</code> or <code>Path</code> objects similar to Java. We'll use a <code>File</code> object here and, for our purposes, we'll just use a temporary file since we are just going to read it back in and check it against our data. Here is how to create a temporary file:</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>file = File.<span style="color:#9876aa;font-style:italic;">createTempFile</span>(<span style="color:#6a8759;">'FemmesStage1Podium'</span>, <span style="color:#6a8759;">'.csv'</span>)</pre>
<p>Writing our CSV (in this simple example) is as simple as joining the data with commas and the lines with line separator character(s):</p>
<pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.<span style="color:#9876aa;">text </span>= data*.join(<span style="color:#6a8759;">','</span>).join(System.<span style="color:#9876aa;font-style:italic;">lineSeparator</span>())</pre>
<p>Here we "wrote" the entire file contents in one go but there are options for writing a line or character or byte at a time.</p><p>Reading the data in is just as simple. We read the lines and split on commas:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">assert </span>file.readLines()*.split(<span style="color:#6a8759;">'</span><span style="color:#6a8759;background-color:#364135;">,</span><span style="color:#6a8759;">'</span>) == data</pre>
<p>In general, we might want to further process the data. Groovy provides nice options for this too. Suppose we have the following existing CSV file:<br>
<img src="https://blogs.apache.org/groovy/mediaresource/0128cd28-23e8-42ca-b408-c2eaf1c82d1c" style="border:1px solid grey; width:60%;" alt="HommesOverall.png"><br>We can read in the file and select various columns of interest with code like below:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>file = <span style="color:#cc7832;">new </span>File(<span style="color:#6a8759;">'HommesStageWinners.csv'</span>)<br><span style="color:#cc7832;">def </span>rows = file.readLines().tail()*.split(<span style="color:#6a8759;">'</span><span style="color:#6a8759;background-color:#364135;">,</span><span style="color:#6a8759;">'</span>)<br><span style="color:#cc7832;">int </span>total = rows.size()<br>Set names = rows.collect <span style="font-weight:bold;">{ </span>it[<span style="color:#6897bb;">1</span>] + <span style="color:#6a8759;">' ' </span>+ it[<span style="color:#6897bb;">2</span>] <span style="font-weight:bold;">}<br></span>Set teams = rows*.getAt(<span style="color:#6897bb;">3</span>)<br>Set countries = rows*.getAt(<span style="color:#6897bb;">4</span>)<br>String result = <span style="color:#6a8759;">"Across </span>$total<span style="color:#6a8759;"> stages, </span>$<span style="font-weight:bold;">{</span>names.size()<span style="font-weight:bold;">}</span><span style="color:#6a8759;"> riders from " </span>+<br>        <span style="color:#6a8759;">"</span>$<span style="font-weight:bold;">{</span>teams.size()<span style="font-weight:bold;">}</span><span style="color:#6a8759;"> teams and </span>$<span style="font-weight:bold;">{</span>countries.size()<span style="font-weight:bold;">}</span><span style="color:#6a8759;"> countries won stages."<br></span><span style="color:#cc7832;">assert </span>result == <span style="color:#6a8759;">'Across 21 stages, 15 riders from 10 teams and 9 countries won stages.'<br></span></pre><p>Here, the <code>tail()</code>&nbsp;method skips over the header line. Column 0 contains the stage number which we ignore. Column 1 contains the first name, column 2 the last name, column 3 the team, and column 4 the country of the rider. We store away the full names, teams and countries in sets to remove duplicates. We then create an overall result message using the size of those sets.</p><p>While for this simple example, the coding was fairly simple, it isn't recommended to hand process CSV files in this fashion. The details for CSV can quickly get messy. What if the values themselves contain commas or newlines? Perhaps we can surround in double quotes but then what if the value contains a double quote? And so forth. For this reason, CSV libraries are recommended.</p><p>We'll look at three shortly, but first let's summarise some of the highlights of the tour by looking at multiple winners. Here is some code which summarises our CSV data:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>byValueDesc = <span style="font-weight:bold;">{ </span>-it.value <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">def </span>bySize = <span style="font-weight:bold;">{ </span>k, v <span style="font-weight:bold;">-&gt; </span>[k, v.size()] <span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">def </span>isMultiple = <span style="font-weight:bold;">{ </span>it.value &gt; <span style="color:#6897bb;">1 </span><span style="font-weight:bold;">}<br></span><span style="color:#cc7832;">def </span>multipleWins = <span style="font-weight:bold;">{ </span>Closure select <span style="font-weight:bold;">-&gt; </span>rows<br>    .groupBy(select)<br>    .collectEntries(bySize)<br>    .findAll(isMultiple)<br>    .sort(byValueDesc)<br>    .entrySet()<br>    .join(<span style="color:#6a8759;">', '</span>)<br><span style="font-weight:bold;">}<br></span>println <span style="color:#6a8759;">'Multiple wins by country:</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>+ multipleWins<span style="font-weight:bold;">{ </span>it[<span style="color:#6897bb;">4</span>] <span style="font-weight:bold;">}<br></span>println <span style="color:#6a8759;">'Multiple wins by rider:</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>+ multipleWins<span style="font-weight:bold;">{ </span>it[<span style="color:#6897bb;">1</span>] + <span style="color:#6a8759;">' ' </span>+ it[<span style="color:#6897bb;">2</span>] <span style="font-weight:bold;">}<br></span>println <span style="color:#6a8759;">'Multiple wins by team:</span><span style="color:#cc7832;">\n</span><span style="color:#6a8759;">' </span>+ multipleWins<span style="font-weight:bold;">{ </span>it[<span style="color:#6897bb;">3</span>] <span style="font-weight:bold;">}<br></span></pre><p>This summary has nothing in particular to do with CSV files but is summarised in honour of the great riding during the tour! Here's the output:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/878dc821-991f-468c-823d-7672ddeccb98" style="width:80%;" alt="MultipleWins.png"><br></p><p>Okay, now let's look at our three CSV libraries.</p>
<h3>Commons CSV</h3>
<p>The <a href="https://commons.apache.org/proper/commons-csv/" target="_blank">Apache Commons CSV</a> library makes writing and parsing CSV files easier. Here is the code for writing our CSV which makes use of the <code>CSVPrinter</code> class:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withWriter <span style="font-weight:bold;">{ </span>w <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">new </span>CSVPrinter(w, CSVFormat.<span style="color:#9876aa;font-style:italic;">DEFAULT</span>).printRecords(data)<br><span style="font-weight:bold;">}<br></span></pre><p>And here is the code for reading it back in which uses the <code>RFC4180</code> parser factory singleton:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">assert </span><span style="color:#9876aa;font-style:italic;">RFC4180</span>.parse(r).<span style="color:#9876aa;">records</span>*.toList() == data<br><span style="font-weight:bold;">}<br></span></pre><p>There are other singleton factories for tab-separated values and other common formats and builders to let you set a whole variety of options like escape characters, quote options, whether to use an enum to define header names, and whether to ignore empty lines or nulls.</p><p>For our more elaborate example, we have a tiny bit more work to do. We'll use the builder to tell the parser to skip the header row. We could have chosen to use the <code>tail()</code> trick we used earlier but we decided to use the parser features instead. The code would look like this:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>rows = <span style="color:#9876aa;font-style:italic;">RFC4180</span>.builder()<br>            .setHeader()<br>            .setSkipHeaderRecord(<span style="color:#cc7832;">true</span>)<br>            .build()<br>            .parse(r)<br>            .<span style="color:#9876aa;">records<br></span><span style="color:#9876aa;">    </span><span style="color:#cc7832;">assert </span>rows.size() == <span style="color:#6897bb;">21<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows.collect <span style="font-weight:bold;">{ </span>it.firstname + <span style="color:#6a8759;">' ' </span>+ it.lastname <span style="font-weight:bold;">}</span>.toSet().size() == <span style="color:#6897bb;">15<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.team.toSet().size() == <span style="color:#6897bb;">10<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.country.toSet().size() == <span style="color:#6897bb;">9<br></span><span style="font-weight:bold;">}<br></span></pre><p>You can see here that we have used column names rather than column numbers during our processing. Using column names is another advantage of using the CSV library; it would be quite a lot of work to do that aspect by hand. Also note that, for simplicity, we didn't create the entire&nbsp;<i>result</i>&nbsp;message as in the earlier example. Instead, we just checked the size of all of the relevant sets that we calculated previously.<br></p>
<h3>OpenCSV</h3>
<p>The <a href="http://opencsv.sourceforge.net/" target="_blank">OpenCSV</a> library handles the messy CSV details when needed but doesn't get in the way for simple cases. For our first example, the <code>CSVReader</code> and <code>CSVWriter</code> classes will be suitable. Here is the code for writing our CSV file in the same way as earlier:<br></p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withWriter <span style="font-weight:bold;">{ </span>w <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">new </span>CSVWriter(w).writeAll(data.collect<span style="font-weight:bold;">{ </span>it <span style="color:#cc7832;">as </span>String[] <span style="font-weight:bold;">}</span>)<br><span style="font-weight:bold;">}<br></span></pre>
<p>And here is the code for reading data:<br></p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">assert new </span>CSVReader(r).readAll() == data<br><span style="font-weight:bold;">}<br></span></pre><p>If we look at the produced file, it is already a little fancier than earlier with double quotes around all data:</p><p><img src="https://blogs.apache.org/groovy/mediaresource/f226d423-3408-4aaa-ba3e-d835e6c894aa" style="width:40%;" alt="FemmesPodiumStage1.png"><br></p><p>If we want to do more elaborate processing, the <code>CSVReaderHeaderAware</code> class is aware of the initial header row and its column names. Here is our more elaborate example which processed some of the data further:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>rows = []<br>    <span style="color:#cc7832;">def </span>reader = <span style="color:#cc7832;">new </span>CSVReaderHeaderAware(r)<br>    <span style="color:#cc7832;">while </span>((next = reader.readMap())) rows &lt;&lt; next<br>    <span style="color:#cc7832;">assert </span>rows.size() == <span style="color:#6897bb;">21<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows.collect <span style="font-weight:bold;">{ </span>it.firstname + <span style="color:#6a8759;">' ' </span>+ it.lastname <span style="font-weight:bold;">}</span>.toSet().size() == <span style="color:#6897bb;">15<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.team.toSet().size() == <span style="color:#6897bb;">10<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.country.toSet().size() == <span style="color:#6897bb;">9<br></span><span style="font-weight:bold;">}<br></span></pre><p>You can see here that we have again used column names rather than column numbers during our processing. For simplicity, we followed the same style as in the Commons CSV example and just checked the size of all of the relevant sets that we calculated previously.</p><p>OpenCSV also supports transforming CSV files into JavaBean instances. First, we define our target class (or annotate an existing domain class):<br></p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">class </span>Cyclist {<br>    <span style="color:#bbb529;">@CsvBindByName</span>(column = <span style="color:#6a8759;">'firstname'</span>)<br>    String <span style="color:#9876aa;">first<br></span><span style="color:#9876aa;">    </span><span style="color:#bbb529;">@CsvBindByName</span>(column = <span style="color:#6a8759;">'lastname'</span>)<br>    String <span style="color:#9876aa;">last<br></span><span style="color:#9876aa;">    </span><span style="color:#bbb529;">@CsvBindByName<br></span><span style="color:#bbb529;">    </span>String <span style="color:#9876aa;">team<br></span><span style="color:#9876aa;">    </span><span style="color:#bbb529;">@CsvBindByName<br></span><span style="color:#bbb529;">    </span>String <span style="color:#9876aa;">country<br></span>}<br></pre><p>For two of the columns, we've indicated that the column name in the CSV file doesn't match our class property. The annotation attribute caters for that scenario.</p><p>Then, we can use this code to convert our CSV file into a list of domain objects:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span>List&lt;Cyclist&gt; rows = <span style="color:#cc7832;">new </span>CsvToBeanBuilder(r).withType(Cyclist).build().parse()<br>    <span style="color:#cc7832;">assert </span>rows.size() == <span style="color:#6897bb;">21<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows.collect <span style="font-weight:bold;">{ </span>it.first + <span style="color:#6a8759;">' ' </span>+ it.last <span style="font-weight:bold;">}</span>.toSet().size() == <span style="color:#6897bb;">15<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.team.toSet().size() == <span style="color:#6897bb;">10<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.country.toSet().size() == <span style="color:#6897bb;">9<br></span><span style="font-weight:bold;">}<br></span></pre><p>OpenCSV has many options we didn't show. When writing files you can specify the separator and quote characters, when reading CSV you can specify column positions, types, and validate data.</p>
<h3>Jackson Databind CSV</h3>
<p>The <a href="https://github.com/FasterXML/jackson-databind" target="_blank">Jackson Databind</a> library supports the&nbsp;<a href="https://github.com/FasterXML/jackson-dataformats-text/tree/master/csv" target="_blank">CSV</a> format (as well as many others).</p><p>Writing CSV files from existing data is simple as shown here for running example:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;">file.withWriter <span style="font-weight:bold;">{ </span>w <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">new </span>CsvMapper().writeValue(w, data)<br><span style="font-weight:bold;">}<br></span></pre><p>This writes the data into our temporary file as we saw with previous examples. One minor difference is that by default, just the values containing spaces will be double quoted but like the other libraries, there are many configuration options to tweak such settings.</p><p>Reading the data can be achieved using the following code:<br></p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>mapper = <span style="color:#cc7832;">new </span>CsvMapper().readerForListOf(String).with(CsvParser.Feature.<span style="color:#9876aa;font-style:italic;">WRAP_AS_ARRAY</span>)<br>file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">assert </span>mapper.readValues(r).readAll() == data<br><span style="font-weight:bold;">}<br></span></pre><p>Our more elaborate example is done in a similar way:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>schema = CsvSchema.<span style="color:#9876aa;font-style:italic;">emptySchema</span>().withHeader()<br><span style="color:#cc7832;">def </span>mapper = <span style="color:#cc7832;">new </span>CsvMapper().readerForMapOf(String).with(schema)<br>file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span><span style="color:#cc7832;">def </span>rows = mapper.readValues(r).readAll()<br>    <span style="color:#cc7832;">assert </span>rows.size() == <span style="color:#6897bb;">21<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows.collect <span style="font-weight:bold;">{ </span>it.firstname + <span style="color:#6a8759;">' ' </span>+ it.lastname <span style="font-weight:bold;">}</span>.toSet().size() == <span style="color:#6897bb;">15<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.team.toSet().size() == <span style="color:#6897bb;">10<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>rows*.country.toSet().size() == <span style="color:#6897bb;">9<br></span><span style="font-weight:bold;">}<br></span></pre><p>Here, we tell the library to make use of our header row and store each row of data in a map.</p><p>Jackson Databind also supports writing to classes including JavaBeans as well as records. Let's create a record to hold our cyclist information:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#bbb529;">@JsonCreator<br></span><span style="color:#cc7832;">record </span>Cyclist(<br>        <span style="color:#bbb529;">@JsonProperty</span>(<span style="color:#6a8759;">'stage'</span>) <span style="color:#cc7832;">int </span>stage,<br>        <span style="color:#bbb529;">@JsonProperty</span>(<span style="color:#6a8759;">'firstname'</span>) String first,<br>        <span style="color:#bbb529;">@JsonProperty</span>(<span style="color:#6a8759;">'lastname'</span>) String last,<br>        <span style="color:#bbb529;">@JsonProperty</span>(<span style="color:#6a8759;">'team'</span>) String team,<br>        <span style="color:#bbb529;">@JsonProperty</span>(<span style="color:#6a8759;">'country'</span>) String country) {<br>    String full() { <span style="color:#6a8759;">"</span>$<span style="color:#9876aa;">first </span>$<span style="color:#9876aa;">last</span><span style="color:#6a8759;">" </span>}<br>}<br></pre><p>Note that again we can indicate where our record component names may not match the names used in the CSV file, we simply supply the alternate name when specifying the property. There are other options like indicating that a field is required or giving its column position but we don't need those options for our example. We've also added a <code>full()</code> helper method to return the full name of the cyclist.</p><p>Groovy will use native records on platforms that support it (JDK16+) or emulated records on earlier platforms.</p><p>Now we can write our code for record deserialization:</p><pre style="background-color:#2b2b2b;color:#a9b7c6;font-family:'JetBrains Mono',monospace;font-size:9.6pt;"><span style="color:#cc7832;">def </span>schema = CsvSchema.<span style="color:#9876aa;font-style:italic;">emptySchema</span>().withHeader()<br><span style="color:#cc7832;">def </span>mapper = <span style="color:#cc7832;">new </span>CsvMapper().readerFor(Cyclist).with(schema)<br>file.withReader <span style="font-weight:bold;">{ </span>r <span style="font-weight:bold;">-&gt;<br></span><span style="font-weight:bold;">    </span>List&lt;Cyclist&gt; records = mapper.readValues(r).readAll()<br>    <span style="color:#cc7832;">assert </span>records.size() == <span style="color:#6897bb;">21<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>records*.full().toSet().size() == <span style="color:#6897bb;">15<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>records*.<span style="color:#9876aa;">team</span>.toSet().size() == <span style="color:#6897bb;">10<br></span><span style="color:#6897bb;">    </span><span style="color:#cc7832;">assert </span>records*.<span style="color:#9876aa;">country</span>.toSet().size() == <span style="color:#6897bb;">9<br></span><span style="font-weight:bold;">}<br></span></pre>
<h3>Conclusion</h3>
<p>We have looked at writing and reading CSV files to Strings and domain classes and records. We had a look at handling simple cases by hand and also looked at the OpenCSV, Commons CSV and Jackson Databind CSV libraries.</p><p>Code for these examples:<br><a href="https://github.com/paulk-asert/CsvGroovy" target="_blank">https://github.com/paulk-asert/CsvGroovy</a><br></p><p>Code for other examples of using Groovy for Data Science:<br><a href="https://github.com/paulk-asert/groovy-data-science" target="_blank">https://github.com/paulk-asert/groovy-data-science</a><br></p><p><br></p><p><br></p>
